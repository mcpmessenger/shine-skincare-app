

#!/bin/bash

# Shine Skincare App - HTTPS Deployment Script
# This script enables HTTPS on the Application Load Balancer

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
STACK_NAME="shine-skincare-https"
ENVIRONMENT="production"
REGION="us-east-1"
DOMAIN_NAME=""  # Set this if you have a custom domain

echo -e "${BLUE}üöÄ Shine Skincare App - HTTPS Deployment${NC}"
echo "================================================"

# Check if AWS CLI is installed (use full path to avoid PATH issues)
AWS_CLI="/usr/local/bin/aws"
if ! [ -x "$AWS_CLI" ]; then
    echo -e "${RED}‚ùå AWS CLI is not installed at $AWS_CLI. Please install it first.${NC}"
    exit 1
fi

# Check if AWS credentials are configured
if ! "$AWS_CLI" sts get-caller-identity &> /dev/null; then
    echo -e "${RED}‚ùå AWS credentials not configured. Please run '$AWS_CLI configure' first.${NC}"
    exit 1
fi

echo -e "${GREEN}‚úÖ AWS CLI and credentials verified${NC}"

# Function to create SSL certificate
create_ssl_certificate() {
    if [ -n "$DOMAIN_NAME" ]; then
        echo -e "${YELLOW}üîê Creating SSL certificate for domain: $DOMAIN_NAME${NC}"
        
        # Request certificate
        CERT_ARN=$("$AWS_CLI" acm request-certificate \
            --domain-name "$DOMAIN_NAME" \
            --validation-method DNS \
            --region "$REGION" \
            --query 'CertificateArn' \
            --output text)
        
        echo -e "${GREEN}‚úÖ SSL certificate created: $CERT_ARN${NC}"
        echo -e "${YELLOW}‚ö†Ô∏è  IMPORTANT: You need to validate the certificate manually${NC}"
        echo -e "${YELLOW}   Check the AWS Console for DNS validation records${NC}"
        
        return 0
    else
        echo -e "${YELLOW}‚ÑπÔ∏è  No custom domain specified. Using ALB default HTTPS.${NC}"
        return 1
    fi
}

# Function to wait for certificate validation
wait_for_certificate_validation() {
    if [ -n "$DOMAIN_NAME" ]; then
        echo -e "${YELLOW}‚è≥ Waiting for SSL certificate validation...${NC}"
        echo -e "${YELLOW}   Please complete DNS validation in AWS Console${NC}"
        
        while true; do
            STATUS=$("$AWS_CLI" acm describe-certificate \
                --certificate-arn "$CERT_ARN" \
                --region "$REGION" \
                --query 'Certificate.Status' \
                --output text)
            
            if [ "$STATUS" = "ISSUED" ]; then
                echo -e "${GREEN}‚úÖ SSL certificate validated successfully${NC}"
                break
            elif [ "$STATUS" = "FAILED" ]; then
                echo -e "${RED}‚ùå SSL certificate validation failed${NC}"
                exit 1
            else
                echo -e "${YELLOW}‚è≥ Certificate status: $STATUS${NC}"
                sleep 30
            fi
        done
    fi
}

# Function to get VPC and subnet information
get_network_info() {
    echo -e "${BLUE}üîç Getting network information...${NC}"
    
    # Get default VPC
    VPC_ID=$("$AWS_CLI" ec2 describe-vpcs \
        --filters "Name=is-default,Values=true" \
        --region "$REGION" \
        --query 'Vpcs[0].VpcId' \
        --output text)
    
    if [ "$VPC_ID" = "None" ]; then
        echo -e "${RED}‚ùå No default VPC found. Please specify VPC ID manually.${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}‚úÖ VPC ID: $VPC_ID${NC}"
    
    # Get public subnets
    SUBNET_IDS=$("$AWS_CLI" ec2 describe-subnets \
        --filters "Name=vpc-id,Values=$VPC_ID" "Name=map-public-ip-on-launch,Values=true" \
        --region "$REGION" \
        --query 'Subnets[*].SubnetId' \
        --output text)
    
    if [ -z "$SUBNET_IDS" ]; then
        echo -e "${RED}‚ùå No public subnets found in VPC $VPC_ID${NC}"
        exit 1
    fi
    
    # Convert space-separated subnet IDs to comma-separated (handle multiple spaces)
    SUBNET_IDS_COMMA=$(echo "$SUBNET_IDS" | sed 's/[[:space:]]\+/,/g' | sed 's/^,//;s/,$//')
    
    echo -e "${GREEN}‚úÖ Public Subnet IDs: $SUBNET_IDS${NC}"
    echo -e "${GREEN}‚úÖ Public Subnet IDs (comma-separated): $SUBNET_IDS_COMMA${NC}"
}

# Function to deploy CloudFormation stack
deploy_stack() {
    echo -e "${BLUE}üöÄ Deploying HTTPS-enabled infrastructure...${NC}"
    
    # Create JSON parameters file for CloudFormation
    PARAMS_FILE="/tmp/cloudformation-params.json"
    
    # Build JSON parameters
    cat > "$PARAMS_FILE" << EOF
[
    {
        "ParameterKey": "VpcId",
        "ParameterValue": "$VPC_ID"
    },
    {
        "ParameterKey": "PublicSubnetIds",
        "ParameterValue": "$SUBNET_IDS_COMMA"
    },
    {
        "ParameterKey": "Environment",
        "ParameterValue": "$ENVIRONMENT"
    }
EOF

    # Add optional parameters if domain is specified
    if [ -n "$DOMAIN_NAME" ]; then
        cat >> "$PARAMS_FILE" << EOF
    },
    {
        "ParameterKey": "DomainName",
        "ParameterValue": "$DOMAIN_NAME"
    },
    {
        "ParameterKey": "SSLCertificateArn",
        "ParameterValue": "$CERT_ARN"
    }
EOF
    fi
    
    # Close the JSON array
    echo "]" >> "$PARAMS_FILE"
    
    echo -e "${BLUE}üìù CloudFormation parameters file created:${NC}"
    cat "$PARAMS_FILE"
    echo ""
    
    # Deploy or update stack
    # Check if stack exists and is in a valid state for updates
    STACK_STATUS=$("$AWS_CLI" cloudformation describe-stacks --stack-name "$STACK_NAME" --region "$REGION" --query 'Stacks[0].StackStatus' --output text 2>/dev/null || echo "STACK_NOT_FOUND")
    
    if [ "$STACK_STATUS" != "STACK_NOT_FOUND" ] && [ "$STACK_STATUS" != "ROLLBACK_COMPLETE" ] && [ "$STACK_STATUS" != "DELETE_COMPLETE" ]; then
        echo -e "${YELLOW}üìù Updating existing stack: $STACK_NAME (Status: $STACK_STATUS)${NC}"
        "$AWS_CLI" cloudformation update-stack \
            --stack-name "$STACK_NAME" \
            --template-body file://infrastructure/load-balancer-cf.yaml \
            --parameters file://"$PARAMS_FILE" \
            --capabilities CAPABILITY_NAMED_IAM \
            --region "$REGION"
        
        echo -e "${YELLOW}‚è≥ Waiting for stack update to complete...${NC}"
        "$AWS_CLI" cloudformation wait stack-update-complete \
            --stack-name "$STACK_NAME" \
            --region "$REGION"
    else
        if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ]; then
            echo -e "${RED}‚ùå Stack $STACK_NAME is in ROLLBACK_COMPLETE state and cannot be updated${NC}"
            echo -e "${YELLOW}üîÑ Deleting failed stack to allow fresh deployment...${NC}"
            "$AWS_CLI" cloudformation delete-stack --stack-name "$STACK_NAME" --region "$REGION"
            echo -e "${YELLOW}‚è≥ Waiting for stack deletion to complete...${NC}"
            "$AWS_CLI" cloudformation wait stack-delete-complete --stack-name "$STACK_NAME" --region "$REGION"
            echo -e "${GREEN}‚úÖ Failed stack deleted successfully${NC}"
        fi
        
        echo -e "${YELLOW}üÜï Creating new stack: $STACK_NAME${NC}"
        "$AWS_CLI" cloudformation create-stack \
            --stack-name "$STACK_NAME" \
            --template-body file://infrastructure/load-balancer-cf.yaml \
            --parameters file://"$PARAMS_FILE" \
            --capabilities CAPABILITY_NAMED_IAM \
            --region "$REGION"
        
        echo -e "${YELLOW}‚è≥ Waiting for stack creation to complete...${NC}"
        "$AWS_CLI" cloudformation wait stack-create-complete \
            --stack-name "$STACK_NAME" \
            --region "$REGION"
    fi
    
    echo -e "${GREEN}‚úÖ Stack deployment completed successfully${NC}"
}

# Function to get stack outputs
get_stack_outputs() {
    echo -e "${BLUE}üìä Getting stack outputs...${NC}"
    
    ALB_DNS=$("$AWS_CLI" cloudformation describe-stacks \
        --stack-name "$STACK_NAME" \
        --region "$REGION" \
        --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
        --output text)
    
    HTTPS_STATUS=$("$AWS_CLI" cloudformation describe-stacks \
        --stack-name "$STACK_NAME" \
        --region "$REGION" \
        --query 'Stacks[0].Outputs[?OutputKey==`HTTPSStatus`].OutputValue' \
        --output text)
    
    echo -e "${GREEN}‚úÖ ALB DNS Name: $ALB_DNS${NC}"
    echo -e "${GREEN}‚úÖ HTTPS Status: $HTTPS_STATUS${NC}"
    echo ""
    echo -e "${BLUE}üîó Service Endpoints:${NC}"
    echo -e "   ML Service: https://$ALB_DNS/ml/"
    echo -e "   API Gateway: https://$ALB_DNS/"
    echo ""
}

# Function to test HTTPS endpoints
test_https_endpoints() {
    echo -e "${BLUE}üß™ Testing HTTPS endpoints...${NC}"
    
    ALB_DNS=$("$AWS_CLI" cloudformation describe-stacks \
        --stack-name "$STACK_NAME" \
        --region "$REGION" \
        --query 'Stacks[0].Outputs[?OutputKey==`ALBDNSName`].OutputValue' \
        --output text)
    
    # Test HTTPS connectivity
    if curl -s -k "https://$ALB_DNS/health" &> /dev/null; then
        echo -e "${GREEN}‚úÖ HTTPS endpoint accessible${NC}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  HTTPS endpoint not yet accessible (may need time to propagate)${NC}"
    fi
}

# Main execution
main() {
    echo -e "${BLUE}Starting HTTPS deployment process...${NC}"
    
    # Create SSL certificate if domain is specified
    if create_ssl_certificate; then
        wait_for_certificate_validation
    fi
    
    # Get network information
    get_network_info
    
    # Deploy infrastructure
    deploy_stack
    
    # Get outputs
    get_stack_outputs
    
    # Test endpoints
    test_https_endpoints
    
    echo ""
    echo -e "${GREEN}üéâ HTTPS deployment completed successfully!${NC}"
    echo ""
    echo -e "${BLUE}üìã Next Steps:${NC}"
    echo "   1. Update your frontend environment variables to use HTTPS URLs"
    echo "   2. Test the new HTTPS endpoints"
    echo "   3. Update any hardcoded HTTP URLs in your code"
    echo ""
    echo -e "${BLUE}üîó Useful Commands:${NC}"
    echo "   View stack: aws cloudformation describe-stacks --stack-name $STACK_NAME"
    echo "   Delete stack: aws cloudformation delete-stack --stack-name $STACK_NAME"
    echo "   View events: aws cloudformation describe-stack-events --stack-name $STACK_NAME"
}

# Run main function
main "$@"
